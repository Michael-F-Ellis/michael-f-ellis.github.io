<!-- This file is auto-generated. Do not edit it manually. -->
<!DOCTYPE html>
<html>
<!--
  This file contains an HTML app for writing and rendering musical scores
  using the FQS notation system.  It defines the structure and layout of the
  score, including the placement of various elements such as title, cue, lyric,
  chord, dynamics, time signature, and pitches.

  The app uses SVG (Scalable Vector Graphics) to render the musical
  notation. The SVG elements are dynamically generated and positioned based on
  the provided musical data and configuration parameters.
  
  To understand how the app works and how the musical data is processed and
  rendered, you can refer to the following sections in the JavaScript code:

  0. The window.onload function: This function is called when the HTML file is
  loaded. It finds all the score elements (div.score) in the HTML file and
  renders them using the `renderEditedScoreSource()` function.
  
  1. The `renderScore()` function: This is the main entry point for rendering a
  score. It sets up the SVG container, applies the necessary transformations,
  and calls the respective rendering functions for each musical element class.
  
  2. The rendering functions for each musical element class (e.g.,
  Title.render(), Cue.render(), Lyric.render(), etc.): These functions handle
  the rendering of specific musical elements based on the provided data. They
  create the necessary SVG elements, set their attributes, and position them
  correctly within the score.
  
  3. The `bookParameters` object: This object contains various configuration
  parameters that control the rendering of the score, such as font heights,
  spacing, and positioning. These parameters are used throughout the rendering
  process to ensure consistent and customizable formatting. Also, see the
  <style> element in the HTML file for the CSS rules that control the formatting
  of the score.
  
  4. The `handleNewScoreButtonClick()` function: This function is called when
  the user clicks the Insert button.  It opens the dialog box for selecting a
  score template. This function is called when the user clicks the Insert
  button. It opens a dialog box where the user can choose an initial score
  template (e.g., Minimal, Full, Cheat sheet) and inserts a new score based on
  the selected template using the insertNewScore() function.
  
  5. The export() and importFromFile() functions: These functions are invoked
  by buttons in the control dropdown at the top of the page. The export
  function saves the current score data to a file and the importFromFile
  function loads a score file, splits the text into individual scores, and
  appends them to the page as separate scores.

  6. Common syntax errors in the pitch line are detected and displayed in the
  rendered output in red text below the line where the error occurred. See the
  LineProblems class and renderScore() for details. Processing continues if
  possible so that the user is not interrupted by a syntax error while
  transcribing a score.
  
  Feel free to explore the code and experiment with different musical data and
  configuration parameters to understand how the app works and how you can
  customize it to suit your needs.
-->

<head>
  <meta charset="utf-8">
  </meta>
</head>

<body>
  <!--YouTube player div-->
  <div id="player"></div>
  <!-- Page controls -->
  <div class="controls" style="margin: 5%;">
    <em>Controls</em><br>
    <button id="exportButton" onclick="exportScores()">Export</button> <em>Save the scores from this page in
      <code>.fqs</code> text
      format.</em><br>
    <button onclick="importFromFile()">Import File</button> <em>Import scores from a local <code>.fqs</code>
      file.</em><br>
    <button onclick="importFromURL()">Import URL</button> <em>Import a <code>.fqs</code> file from a URL.</em><br>
    <button id="edit-btn">Show edit controls</button> <em>Display the editable source beside the score. </em>

    <script>
      // Add right after the first <script> tag
      let tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      tag.onload = () => {
        console.log('YouTube IFrame API script loaded');
      };
      let firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      let editModeState = true;
      const editButton = document.getElementById('edit-btn');
      function toggleEdit() {
        editModeState = !editModeState;
        forceEditMode(editModeState);
      }
      function forceEditMode(boolValue) {
        newScoreBtnsVisible(editModeState);
        const scoreDivs = document.querySelectorAll('div.score');
        scoreDivs.forEach(div => {
          const editor = div.querySelector('div.source-div');
          const rendered = div.querySelector('div.inner-wrapper');
          const deleteBtn = div.querySelector('button.delete-btn');
          if (editModeState) {
            editor.style.display = 'block';
            editor.style.width = '50%';
            rendered.style.width = '50%';
            deleteBtn.style.display = 'inline-block';
            editButton.textContent = 'Hide edit controls';
          } else {
            editor.style.display = 'none';
            rendered.style.width = '100%';
            deleteBtn.style.display = 'none';
            editButton.textContent = 'Show edit controls';
          }
        });
      }
      editButton.addEventListener('click', toggleEdit);
    </script>

  </div>
  <h3>
    Scores
  </h3>
  <div id="score-toc" class="score-toc">
  </div>
  <button id="first-new-score-btn" , class="new-score-btn" onclick="handleNewScoreButtonClick(event)">
    Insert New Score
  </button>
  <dialog id=new-score-dialog>
    <form method="dialog">
      <p>Choose an initial score template:</p>
      <label><input type="radio" name="choice" value="1" checked> Minimal</label><br>
      <label><input type="radio" name="choice" value="3"> FQS Reference</label><br>
      <button id="cancelBtn" type="reset">Cancel</button>
      <button id="confirmBtn" type="submit">Confirm</button>
    </form>
  </dialog>
  <!-- The CSS styles for the score editor and display -->
  <style id="fqs-style">
    html,
    body {
      width: 100%;
    }

    summary {
      margin-left: 5%;
    }

    img {
      margin-left: 5%;
    }

    button {
      margin: 2px;
    }

    button.new-score-btn {
      margin-left: 5%;
    }

    button.delete-btn {
      margin-left: 5%;
    }

    div.edit {
      width: 100%;
      margin-left: 0;
      margin-right: 0;
      margin-top: 2em;
      margin-bottom: 2em;
      padding-left: 5%;
    }

    details.controls summary {
      width: 100%;
      margin-left: 0;
      margin-right: 0;
      margin-top: 2em;
      margin-bottom: 0;
      padding-left: 0%;
    }

    div.score,
    div.score-toc {
      width: 100%;
      margin-left: 0;
      margin-right: 0;
      margin-top: 2em;
      margin-bottom: 2em;
      padding: 0;
    }

    .edit-button {
      background: none;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 16px;
    }

    .edit-button:hover {
      background: #f0f0f0;/ad/add
    }

    /* Font sizes (adjusted dynamically at render time) */
    .lineproblem {
      font: 8px monospace;
      fill: red;
    }

    .title {
      font: 18px sans-serif;
    }

    .preface {
      font: 10px sans-serif;
    }

    .postscript {
      font: 10px sans-serif;
    }

    .text {
      font: 10px sans-serif;
    }

    /* chord name, e.g. 'C' */
    .chord {
      font-family: monospace;
      font-size: 13px;
      font-style: bold;
    }

    /* chord text, e.g. 'maj7' */
    .chord-text {
      font-family: Arial, sans-serif;
      font-size: 8px;
      font-style: bold;
    }

    .grey {
      fill: rgb(160, 160, 160);
    }

    .lyric {
      font: 12px monospace;
    }

    .rest,
    .pitch {
      font: 12px monospace;
    }

    .chord-pitch {
      font: 10px monospace;
    }

    .pernote {
      font: 8px monospace;
      font-style: italic;
    }

    .fingering {
      font: 4px monospace;
    }

    .perbar {
      font: 8px monospace;
      font-style: italic;
    }

    .counter {
      font: 6px monospace;
      font-style: italic;
    }

    .perbeat {
      font: 6px monospace;
      font-style: italic;
    }

    .cue {
      /* cue text */
      fill: rgb(84, 84, 84);
      font: 8px monospace;
    }

    /* Note that the color of the text is set with the    *
       * fill property, the color property is for HTML only */
    .‚ô≠ {
      /* flat */
      fill: rgb(152, 140, 254);
      /* font-style: italic; */

    }

    .ùÑ´ {
      /* double flat */
      fill: rgb(4, 182, 4);
      font-style: italic;
    }

    .‚ôØ {
      /* sharp */
      fill: red;
      /* font-style: italic; */
    }

    .ùÑ™ {
      /* double sharp */
      fill: orange;
      font-style: italic;
    }

    .link-to-toc {
      /* toc links should be at the right edge of the document */
      position: absolute;
      right: 5%;

    }

    h2,
    h3,
    p,
    ul,
    ol {
      margin-left: 5%;
      margin-right: 5%;
    }

    /* styles for side by side layout */
    div.score-wrapper {
      display: flex;
      flex-direction: row;
    }

    div.inner-wrapper {
      position: sticky;
      top: 0;
      padding-left: 1%;
      overflow-y: auto;
    }

    pre.source {
      position: sticky;
      top: 0;
      padding-left: 5%;
      overflow-y: auto;
    }

    .section-editor {
      width: 90%;
      min-height: 100px;
      margin: 10px 5% 5% 10px;
      padding: 1em;
      border: 1px solid #ccc;
      background: #f5f5f5;
    }

    /* Center SVG elements with 5% padding left, right and bottom*/
    svg {
      padding-left: 5%;
      display: block !important;
      width: 100% !important;
    }
  </style>
  <script type="text/javascript">
    const scoreMap = new Map();
    let isDirty = false; // global flag that is set when we edit a score and cleared when export the scores
    const bookParameters = {
      // bookParameters control the behavior of the score editor and display.
      leftX: 7, // Pixel position of the left edge of the score.
      sideBySide: true, // if true, render scores side-by-side with edit area
      barlineRgx: /:?\|:?/, // regular expression to match barlines
      lyricRgx: /[\p{L}']/u, // regular expression to match lyric alpha characters and apostrophes
      "lyricFontWidth": 7, // includes space between letters
      // Various font size parameters are are added to this object at runtime by 
      // by the updateFontSizes() function in this file. These are needed by the functions
      // that render the scores. If you need to change the font size, you should do so 
      // in the style tag in this file with id "fqs-style".
    }
    // Minimal player initialization. This implementation avoids third-party cookie issues.
    // See https://stackoverflow.com/a/64444601/426853
    let player;
    function onYouTubeIframeAPIReady() {
      console.log('YouTube IFrame API ready');
      player = new YT.Player('player', {
        height: '0',
        width: '0',
        videoId: '',
        host: 'https://www.youtube-nocookie.com',
        playerVars: {
          'playsinline': 1,
          origin: window.location.host
        }
      });
    }


    // appendSVGTextChild(svg, x, y, textContent, classList) adds a text element
    // to the svg element with the given x, y coordinates and textContent. The
    // classList argument is an array of class names to be added to the text
    // element. The text element is returned.
    function appendSVGTextChild(svg, x, y, textContent, classList) {
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", x);
      text.setAttribute("y", y);
      text.textContent = textContent;
      // Check if this pitch is part of a chord
      let rotate = 0;
      if (classList.includes('chord-pitch')) {
        rotate = 340; // rotate 20 degrees counterclockwise
      }
      text.setAttribute("transform", `rotate(${rotate}, ${x}, ${y})`);
      if (classList) {
        text.classList.add(...classList);
      }
      svg.appendChild(text);
      return text;
    }

    // The LineProblem class holds error and warning messages generated during
    // rendering of a score. It has a render method that will render the messages
    // into the SVG element immediately below the line where the problems were
    // encountered.
    class LineProblem {
      constructor() {
        this.messages = []
      }
      add = (function (message) {
        this.messages.push(message);
      });
      clear = (function () {
        this.messages = [];
      });
      render = (function (svg, x0, y0) {
        // Draw each message in this.messages starting at x0, y0 and incrementing y
        // by bookParameters.problemFontHeight for each message.
        let y = y0;
        this.messages.forEach((function (message) {
          y += 1.1 * bookParameters.lineproblemFontHeight;
          appendSVGTextChild(svg, x0, y, "‚ö†Ô∏è" + message, ["lineproblem"]);
        }));
        return y
      });
    } // end of LineProblem class 
    // instantiate a singleton LineProblem to be used by all rendering operations
    const lineProblems = new LineProblem();

    // The LyricLine class interprets the text of a lyric line and
    // and determines the location of beats, attacks and barlines.
    // It provides a render() method that will render the lyric line
    // into an svg element. The tight and show arguments control the
    // spacing of the rendered score. We need both of these to handle
    // the distinction music line groups (which never show lyrics)
    // pitch plus lyric groups where lyrics are shown and tight is
    // ignored.
    class LyricLine {
      constructor(text, tight, show) {
        // trim leading or trailing whitespace
        // split the text on whitespace
        // join the text back together with single spaces
        this.words = text.trim().split(/\s+/);
        this.text = this.words.join(" ");
        // Create an array of attack indices. An attack is an alpha character [a-zA-Z]
        // that is preceded by a any of the following:
        //   a space,
        //   a left parenthesis '(',
        //   the beginning of the text,
        //   a dash '-',
        //   a period '.', or
        //   an asteri
        // We need to store the indices of the attacks in the text as well as
        // the indices of the beats and barlines. We use these indices to
        // position pitch symbols and annotations.
        // A beat begins with a space (or the beginning of the text)
        // followed by an alpha character [a-zA-Z], a dash '-', a rest ';' or an asterisk '*'.
        // We also support chords. If the the left parenthesis that begins a chord
        // is preceded by a space (or the beginning of the text), that is also
        // a beat start.
        this.beats = []; // beat positions
        this.bars = [0,]; // barline positions
        this.attacks = [];
        this.rests = []
        this.tight = tight;
        this.showLyric = show;
        // Call this closure to detect a beat and push its position
        const detectAndPushBeat = (i, pos) => {
          if (i == 0 || (this.text[i - 1] == " ")) {
            this.beats.push(pos);
            return;
          }
          if ((this.text[i - 1] == '(') && (i == 1 || (this.text[i - 2] == ' '))) {
            this.beats.push(pos);
          }
        }
        // loop over the lyric text, detecting the positions of attacks, beats,
        // rests and barlines.
        let pos = 0; // position index
        for (let i = 0; i < this.text.length; i++) {
          const c = this.text[i];
          switch (c) {
            case " ":
              // Spaces advance pos only if tight is false or show is true.
              if (!tight || show) {
                pos++
              }
              continue;
            case "(":
              // ignore left parenthesis. Don't advance pos.
              continue;
            case ")":
              // ignore right parenthesis. Don't advance pos.
              continue;
            case "|":
              // barlines are never attacks or beat starts
              this.bars.push(pos);
              pos++
              continue;
            case "-":
              // a dash is never an attack but it may be a beat start.
              detectAndPushBeat(i, pos);
              pos++;
              continue;
            case ";":
              this.rests.push(pos);
              // a rest is never an attack but it may be a beat start.
              detectAndPushBeat(i, pos);
              pos++;
              continue;
            case ".":
              // a period is indicates that the next character is an attack
              // within a beat.  We check for that in the lyric regex case, so
              // we don't need to do anything here except advance pos.
              pos++
              continue;
            case "*":
              // an asterisk is always an attack. It is also a beat start if
              // it is preceded by a space (or the beginning of the text) or
              // a space followed by a left parenthesis, i.e. " ("
              this.attacks.push(pos);
              detectAndPushBeat(i, pos);
              pos++;
              continue;
            default:
              // Handle lyric characters (including pitch characters).
              if (c.match(bookParameters.lyricRgx)) {
                if (!show) {
                  // This lyric is synthesized from the a music line. The only chars
                  // that match lyricRgx will be /[a-g]/. These chars are always attacks
                  // in this situation. 
                  this.attacks.push(pos);
                  detectAndPushBeat(i, pos);
                } else { // we are showing the lyric
                  if (i == 0 || (this.text[i - 1].match(/[\(\s\-.;\*]/))) {
                    this.attacks.push(pos);
                    detectAndPushBeat(i, pos);
                  }
                }
                pos++
              }
          }
        }
        console.log("\ntext: " + this.text)
        console.log("bars: " + this.bars)
        console.log("beats: " + this.beats)
        console.log("attacks: " + this.attacks)
        console.log("rests: " + this.rests)
      }

      extractRhythm = (function () {
        // Extract the rhythm from the text of the lyric line.
        // The rhythm is the sequence of subdivided beat texts
        // The rhythm is returned as an array of strings of beats, e.g. 
        // "foo.bar - ;baz * |n" would return ["**", "-", ";*", "*"]
        let rhythm = [];
        // parse each each element of this.words, substituting '*' for attacks
        // to produce the desired result
        this.words.forEach((function (word) {
          let beat = '';
          // Handle words containing barlines. The simplest case is a single barline
          // surrounded by whitespace.  We simply ignore it and return to the
          // top of the loop.
          // The same also applies to barlines with repeat indicators, ':|', '|:' and ':|:'
          // On the other hand if any of these four barline possibilities had text prepended or appended
          // with no intervening whitespace, we need to remove barline chars and continue to the 
          // bottom of the loop.
          const barlineChars = /[\|:]+/;
          // We have to handle the possibility of barlines embedded in a word, e.g. "foo|bar"
          // We can't simply delete the barline chars with a space, because "foo|bar"
          // is actually 2 beats.  We need to split the word into two words, "foo" and "bar"
          // and then process each word separately.
          const beatWords = word.split(barlineChars)
          beatWords.forEach((function (beatWord) {
            if (beatWord.length == 0) {
              return;
            }
            // Replace each syllable with an asterisk, honoring '.' syllable separators
            // and removing apostrophes.
            // example: "l'en.fer" -> "**"
            beatWord = beatWord.replace(/'/g, '')  // Remove apostrophes
              .replace(/\p{L}+/gu, '*')            // Replace letter sequences with '*'
              .replace(/\./g, '');                 // Remove dots
            rhythm.push(beatWord);
          }));
        }));
        return rhythm
      });


      render = (function render(svg, x0, y0, fontwidth) {
        if (this.tight && !this.showLyric) { return; } // tight mode does not render lyric lines as part of music lines
        // Draw each char in this.text starting at x0, y0 and incrementing
        // x by fontwidth for each char.
        let x = x0;
        for (let i = 0; i < this.text.length; i++) {
          let char = this.text[i];
          let klass = ["lyric"];
          // Emphasize beats, by greying every char that isn't either a barline
          // or the start of beat.
          if ((char == '-' || char == ';' || char == '*') && !this.beats.includes(i)) {
            klass.push("grey")
          }
          appendSVGTextChild(svg, x, y0, char, klass);
          // increment x by the width of the char
          x += fontwidth;
        }
      });

    } // end of LyricLine class



    // VOffsets is a top-level object used by the Pitch class when rendering
    // pitches. The offsets are fractions of the font height.
    // where h is the font height.  Note that svg coordinates increase from
    // the top of the viewport, hence the reverse ordering for the 12 pitch
    // classes. The letter 'f' is empiricaly lowered .6 units to make it
    // appear a little lower than 'g', i.e. to compensate for the visual
    // effect of 'g's descender.
    const vOffsets = {
      "ùÑ™a": 1, "‚ôÆb": 1, "‚ô≠c": 13,   // B enharmonics (special case for C‚ô≠)
      "‚ôØa": 2, "‚ô≠b": 2, "ùÑ´c": 14,   // B-flat enharmonics (special case for CùÑ´)
      "ùÑ™g": 3, "‚ôÆa": 3, "ùÑ´b": 3,    // A enharmonics
      "‚ôØg": 4, "‚ô≠a": 4,              // A-flat enharmonics
      "ùÑ™f": 5.6, "‚ôÆg": 5, "ùÑ´a": 5,    // G enharmonics
      "ùÑ™e": 6, "‚ôØf": 6.6, "‚ô≠g": 6,    // G-flat enharmonics
      "‚ôØe": 7, "‚ôÆf": 7.6, "ùÑ´g": 7,     // F enharmonics
      "ùÑ™d": 8, "‚ôÆe": 8, "‚ô≠f": 8.6,     // E enharmonics
      "‚ôØd": 9, "‚ô≠e": 9, "ùÑ´f": 9.6,    // E-flat enharmonics
      "ùÑ™c": 10, "‚ôÆd": 10, "ùÑ´e": 10, // D enharmonics
      "ùÑ™b": -1, "‚ôØc": 11, "‚ô≠d": 11, // D-flat enharmonics
      "‚ôØb": 0, "‚ôÆc": 12, "ùÑ´d": 12, // C enharmonics
    }

    // keyTable maps a key signature to a table of accidentals for each pitch class.
    // Key signatures are specified as a string containing a number of sharps or flats,
    // e.g. "0" for C major, "#1" for G major, "#2" for D major, etc. For flats, the key sig
    // looks like "&1", for F major, "&2" for B-flat major, etc.
    const keyTable = {
      "0": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#1": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#2": { "c": "‚ôØ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#3": { "c": "‚ôØ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#4": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôÆ", "b": "‚ôÆ" },
      "#5": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôÆ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôØ", "b": "‚ôÆ" },
      "#6": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôØ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôØ", "b": "‚ôÆ" },
      "#7": { "c": "‚ôØ", "d": "‚ôØ", "e": "‚ôØ", "f": "‚ôØ", "g": "‚ôØ", "a": "‚ôØ", "b": "‚ôØ" },
      "&1": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ôÆ", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ô≠" },
      "&2": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ôÆ", "b": "‚ô≠" },
      "&3": { "c": "‚ôÆ", "d": "‚ôÆ", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ô≠", "b": "‚ô≠" },
      "&4": { "c": "‚ôÆ", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ôÆ", "a": "‚ô≠", "b": "‚ô≠" },
      "&5": { "c": "‚ôÆ", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ô≠", "a": "‚ô≠", "b": "‚ô≠" },
      "&6": { "c": "‚ô≠", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ôÆ", "g": "‚ô≠", "a": "‚ô≠", "b": "‚ô≠" },
      "&7": { "c": "‚ô≠", "d": "‚ô≠", "e": "‚ô≠", "f": "‚ô≠", "g": "‚ô≠", "a": "‚ô≠", "b": "‚ô≠" },
    }
    // When transposing, we need to be able to look up the letter for a given key signature.
    const keyLetters = {
      "0": "c", "#1": "g", "#2": "d", "#3": "a", "#4": "e", "#5": "b", "#6": "f#", "#7": "c#",
      "&1": "f", "&2": "b", "&3": "e", "&4": "a", "&5": "d", "&6": "g", "&7": "c",
    }
    // StringRing provide methods to treat the characters in a string as values
    // in a ring buffer. It provide methods to advance by n and to compute the
    // distance between two values. Its main use in this script is in
    // transposing pitches.
    class StringRing {
      constructor(s) {
        this.r = s.split('');
        this.len = this.r.length;
      }
      distance = (c0, c1) => {
        const i0 = this.r.indexOf(c0);
        if (i0 == -1) {
          throw new Error(`invalid character: ${c0} not in ${this.r}`);
        }
        const i1 = this.r.indexOf(c1);
        if (i1 == -1) {
          throw new Error(`invalid character: ${c1} not in ${this.r}`);
        }
        return (i1 - i0 + this.len) % this.len
      }
      advance = (c, n) => {
        const i = this.r.indexOf(c);
        if (i == -1) {
          throw new Error(`invalid character: ${c} not in ${this.r}`);
        }
        const d = (i + n + this.len) % this.len;
        return this.r[d];
      }
    }

    class Transposer {
      constructor(fromKeySym, toKeySym) {
        this.pitchRing = new StringRing("cdefgab");
        this.fromKeyLetter = keyLetters[fromKeySym];
        this.toKeyLetter = keyLetters[toKeySym];
        this.distance = this.pitchRing.distance(this.fromKeyLetter, this.toKeyLetter);
        this.fromKeyLUT = keyTable[fromKeySym];
        this.toKeyLUT = keyTable[toKeySym];
      }
      components = (pitchToken) => {
        // A pitch token consists of octave marks + accidentals + pitch letter.
        // We need to extract each of these parts.
        const rgx = /([\^\/]*)([&#%]*)([a-g])/;
        const matches = pitchToken.match(rgx);
        const o = matches[1];
        const a = matches[2];
        const l = matches[3];
        return { "octaveMarks": o, "accidentals": a, "letter": l };
      }
      getEffectiveAlteration = (acc, letter) => {
        // The effective alteration is the number of semitones by which a pitch is
        // altered relative to the key signature value for the given letter.
        const alteration = this.fromKeyLUT[letter];
        switch (acc) {
          case '':
            return 0;
          case '%':
            switch (alteration) {
              case '‚ôÆ':
                return 0;
              case '‚ôØ':
                return -1;
              case '‚ô≠':
                return 1;
              default:
                throw new Error(`invalid alteration: ${alteration}`);
            }
          case '&':
            switch (alteration) {
              case '‚ôÆ':
                return -1;
              case '‚ôØ':
                return -2;
              case '‚ô≠':
                return 0;
              default:
                throw new Error(`invalid alteration: ${alteration}`);
            }
          case '#':
            switch (alteration) {
              case '‚ôÆ':
                return 1;
              case '‚ôØ':
                return 0
              case '‚ô≠':
                return 2;
              default:
                throw new Error(`invalid alteration: ${alteration}`);
            }
          case '&&':
            switch (alteration) {
              case '‚ôÆ':
                return -2;
              case '‚ôØ':
                return -3; // may be pathological
              case '‚ô≠':
                return -1;
              default:
                throw new Error(`invalid alteration: ${alteration}`);
            }
          case '##': {
            switch (alteration) {
              case '‚ôÆ':
                return 2;
              case '‚ôØ':
                return 1;
              case '‚ô≠':
                return 3; // may be pathological
              default:
                throw new Error(`invalid alteration: ${alteration}`);
            }
          }
          default:
            throw new Error(`invalid accidental: ${acc}`);
        }

      }
      applyEffectiveAlteration(nAlt, letter) {
        // return an accidentals string that applies the effective alteration, nAlt,
        // to pitch letter in the destination key.
        const keyAlt = this.toKeyLUT[letter];
        switch (nAlt) {
          case 0:
            return '';
          case 1:
            switch (keyAlt) {
              case '‚ôÆ':
                return '#';
              case '‚ôØ':
                return '##';
              case '‚ô≠':
                return '%';
              default:
                throw new Error(`invalid alteration: ${keyAlt}`);
            }
          case -1:
            switch (keyAlt) {
              case '‚ôÆ':
                return '&';
              case '‚ôØ':
                return '%';
              case '‚ô≠':
                return '&&';
              default:
                throw new Error(`invalid alteration: ${keyAlt}`);
            }
          case -2:
            switch (keyAlt) {
              case '‚ôÆ':
                return '&&';
              case '‚ôØ':
                return '&';
              case '‚ô≠':
                throw new Error(`can't represent triple flat`)
              default:
                throw new Error(`invalid alteration: ${keyAlt}`);
            }
          case 2:
            switch (keyAlt) {
              case '‚ôÆ':
                return '##';
              case '‚ôØ':
                throw new Error(`can't represent triple sharp`)
              case '‚ô≠':
                return '#';
              default:
                throw new Error(`invalid alteration: ${keyAlt}`);
            }
          case 3:
            switch (keyAlt) {
              case '‚ôÆ':
                throw new Error(`can't represent triple sharp`)
              case '‚ôØ':
                throw new Error(`can't represent quadruple sharp`)
              case '‚ô≠':
                return '##';
              default:
                throw new Error(`invalid alteration: ${keyAlt}`);
            }
          case -3:
            switch (keyAlt) {
              case '‚ôÆ':
                throw new Error(`can't represent triple flat`)
              case '‚ôØ':
                return '&&';
              case '‚ô≠':
                throw new Error(`can't represent quadruple flat`)
              default:
                throw new Error(`invalid alteration: ${keyAlt}`);
            }
          default:
            throw new Error(`invalid effective alteration: ${nAlt}`);
        }
      }
      transposed = (pitchToken) => {
        // split the pitchToken into components
        const c = this.components(pitchToken);
        // transpose the pitch letter
        const newLetter = this.pitchRing.advance(c.letter, this.distance);
        const nalt = this.getEffectiveAlteration(c.accidentals, c.letter);
        const newAccidental = this.applyEffectiveAlteration(nalt, newLetter);
        return c.octaveMarks + newAccidental + newLetter;
      }
    }

    // The Alterations class is used to manage the alterations for a given key signature
    // and to keep track of which pitches have been explicitly altered within a bar.
    class Alterations {
      constructor(keysym) {
        this.keyLUT = keyTable[keysym];
        // We allow for incomplete key signatures to avoid raising errors
        // while the user is typing.  If the key signature is invalid, we
        // set the key to "0" (C major) and log a warning.
        if (this.keyLUT === undefined) {
          this.keyLUT = keyTable["0"];
          lineProblems.add("invalid or incomplete keysym: " + keysym);
        }
        this.altered = {}
      }
      setKey = () => {
        this.keyLUT = keyTable[keysym];
      }
      initAltered = () => {
        this.altered = {};
      }
      get = (pitchSym, octave, alteration) => {
        // if alteration is not "?", update the altered table entry with the new
        // alteration and return the alteration
        const pitch = pitchSym + octave;
        if (alteration !== "?") {
          this.altered[pitch] = alteration;
          return alteration
        }
        // Otherwise, the value '?' means we need to look up the pitch in the altered
        // table to see if it has a prior alteration. If it does, return that, otherwise
        // look it up in keyLUT and return the value from that.
        if (this.altered[pitch] !== undefined) {
          return this.altered[pitch];
        }
        return this.keyLUT[pitchSym];
      }
    } // end of Alterations class

    // The Pitch class is used to render a single pitch. It is instantiated with a
    // letter, octave and accidental class. The accidental class is a UTF-8 character
    // for natural, sharp, flat, double-sharp or double-flat. The render() method
    // draws the pitch letter at the proper x, y location within the svg with the
    // color and font specified in the style sheet for its accidental class.
    class Pitch {
      constructor(letter, octave, accidentalClass, fontheight) {
        this.letter = letter;
        this.octave = octave; // octave is an offset relative to a center octave whose value is 0
        this.accidentalClass = accidentalClass; // one of '', 'ùÑ´', '‚ôØ', 'ùÑ™' or ''
        this.classes = [accidentalClass, "pitch"];
      }
      // addClass() is used to add a class to the pitch. At present, this is used to add the
      // 'chord-pitch' class to the pitch when it is part of a chord.
      addClass = (className) => {
        this.classes.push(className);
      }
      // render() is a closure that renders the pitch at the specified x, y coordinates.
      render = (function render(svg, x, y, fontheight) {
        // Draw the pitch at the specified x, y coordinates.
        // Adjust the y coordinate by the octave and vertical offset for this pitch
        y -= this.octave * fontheight;
        const gOffset = 7 // causes the pitch to be rendered as though each staff line is on g natural.
        y += (gOffset + vOffsets[this.accidentalClass + this.letter]) * (fontheight / 12);
        appendSVGTextChild(svg, x, y, this.letter, this.classes);
      });
    }
    // The PitchLine class is used to render a single line of pitches from a
    // text string.  This is the most complicated class in the program as it
    // must handle octavation, key signatures, accidentals and alterations and
    // match each pitch to its corresponding attack location in the Lyric line.
    class PitchLine {
      constructor(text) {
        this.centerOctave = 0;
        this.text = text;
        // trim leading or trailing whitespace
        this.text = this.text.trim();
        // split the text on whitespace
        this.beatTokens = text.split(/\s+/);
        // A beat token may contain one or pitch tokens, e.g "c^&d&e"
        // We need to split these into individual pitch tokens. A pitch
        // token is zero or more of [^/] followed by zero or more of [#&%]
        // followed by exactly one of [a-g]. So, for example, "c^&d//&e"
        // would be split into ["^c", "&d", "//&e"]. It's permissible, but
        // not required, to include bar lines in the source to make it a little
        // easier to read and edit. However, omitting bar lines may result
        // in accidentals propagating beyond the bar lines defined in the lyric line.
        this.tokens = [];
        let pitchToken = "";
        for (let i = 0; i < this.beatTokens.length; i++) {
          let beatToken = this.beatTokens[i];
          // Handle key designator of the form "K[#&]?[0-7]".
          // The key designator is optional, so if it's not there, we'll just
          // use the default key of C major.

          if (beatToken.match(/K.*/)) {
            this.tokens.push(beatToken);
            continue
          }
          if (beatToken.match(/:*\|:*/)) {
            this.tokens.push(beatToken);
            continue
          }
          // If the beat token is empty, just skip it.
          if (beatToken.length === 0) {
            continue;
          }
          // Now we split the beat token into individual pitch tokens.
          // let pitchToken = "";
          for (let j = 0; j < beatToken.length; j++) {
            if (beatToken == '|' || beatToken == '|:' || beatToken[j] == ':|') {
              this.tokens.push(beatToken)
            } else if (beatToken[j].match(/\(/)) {
              pitchToken += beatToken[j];
            } else if (beatToken[j].match(/[\^\/]/)) {
              pitchToken += beatToken[j];
            } else if (beatToken[j].match(/[#&%]/)) {
              pitchToken += beatToken[j];
            } else if (beatToken[j].match(/[a-g]/)) {
              pitchToken += beatToken[j];
              this.tokens.push(pitchToken);
              pitchToken = "";
            } else if (beatToken[j].match(/\)/)) {
              pitchToken += beatToken[j];
            } else {
              //throw new Error("Invalid pitch token: " + beatToken);
              lineProblems.add("Invalid pitch token: " + beatToken);
            }
          }
        }


        // Next we parse the tokens into an array of pitch objects.
        // The octave of each pitch depends on the prior pitch. To
        // begin, we let the prior pitch be C natural on the center
        // octave.
        let prevPitch = new Pitch("c", this.centerOctave, "");
        // A pitch token always ends with a letter in [a-g].
        // It may optionally be preceded by at most one of the following accidentals
        // "##", "&&", "#", "&", or '%'.
        // where ## is double-sharp, && is double-flat, # is sharp, and & is flat.
        // The accidentals and letter are optionally preceded by octavation marks, `^ ` and ` / `.
        // It is an error to mix '^`' and ' / ' in a single pitch token. It is also an
        // error if the octave marks cause the new octave be less than -3 or greater than 3.
        // The following are all valid pitch tokens:
        // 'g', '#f', '^b', '//&d', '&&f'
        // The following are all invalid pitch tokens:
        // 'h', '###f', '#&g', '^/a'
        this.pitches = [];
        this.inChord = -1;
        this.alterations = new Alterations("0"); // default key is C major
        for (let i = 0; i < this.tokens.length; i++) {
          // Handle key designator of the form "K(0|[#&]?[1-7])".
          if (this.tokens[i].match(/K/)) {
            this.alterations = new Alterations(this.tokens[i].slice(1));
            continue;
          }
          // If the pitch token begins with a ')', we're ending a chord.
          if (this.tokens[i].match(/\)/)) {
            this.inChord = -1;
            // remove the ')' from the token
            this.tokens[i] = this.tokens[i].slice(1);

          }
          // If the pitch token begins with a '(', we're starting a chord.
          if (this.tokens[i].match(/\(/)) {
            this.inChord = 1;
            // remove the '(' from the token
            this.tokens[i] = this.tokens[i].slice(1);

          }
          // first, get the pitch letter from the token
          // it's the last char in the token. It's an error if the token is empty
          // or if the token does not end with a letter in [a-g]
          let token = this.tokens[i];
          if (token.length === 0) {
            // throw new Error("Empty pitch token");
            lineProblems.add("Empty pitch token");
          }
          if (token == "|" || token == "|:" || token == ":|") {
            this.alterations.initAltered();
            continue
          }
          let letter = token[token.length - 1];
          if (!letter.match(/[a-g]/)) {
            // throw new Error("Invalid pitch token: " + token);
            lineProblems.add("Invalid pitch token: " + token);
          }
          // Next we compare the pitch letter to the previous pitch
          // letter and apply the Lilypond rule of fourths to
          // determine if the pitch will be above or below the
          // previous pitch. The rule of fourths is a way to default
          // to the closest pitch to the previous one. It states that
          // we must choose the pitch which is within a musical 4th of
          // the previous pitch.  Thus, if the previous pitch is 'g'
          // in octave 4 and the current pitch letter is 'f', we
          // should choose the 'f' in octave 4 rather than 'f' in
          // octave 5.  Similarly if the previous pitch is 'g' in
          // octave 4 and the current pitch letter is 'c', we should
          // choose the 'c' in octave 5 rather than 'c' in octave 4
          // because that is the closest.

          // get the pitch letter of the previous pitch
          let prevLetter = prevPitch.letter;
          // get the octave of the previous pitch
          let prevOctave = prevPitch.octave;
          // Make a map of pitch letters:
          let PitchMap = new Map([
            ["c", 0],
            ["d", 1],
            ["e", 2],
            ["f", 3],
            ["g", 4],
            ["a", 5],
            ["b", 6]
          ]);
          // get the pitch letter index of the previous pitch
          let prevLetterIndex = PitchMap.get(prevLetter);
          // get the pitch letter index of the current pitch
          let letterIndex = PitchMap.get(letter);
          // Subtract the indices
          let diff = letterIndex - prevLetterIndex;
          // If the difference is positive and less than 4, the current pitch is
          // above the previous pitch in the same octave. If the difference is positive
          // and greater than 3, the current pitch is below the previous pitch in the next octave down.
          let octave = prevOctave;
          if (diff > 0 && diff > 3) {
            // the current pitch is below the previous pitch in the next octave down
            // so decrement the octave
            octave--;
          } else if (diff < 0 && diff < -3) {
            // the current pitch is above the previous pitch in the previous octave up
            // so increment the octave
            octave++;
          }
          // Now we must account for octave marks, if any.	
          let kind = "";
          let j = 0;
          let done = false;
          while (j < token.length) {

            switch (token[j]) {
              case "^":
                if (kind === "/") {
                  // throw new Error("Invalid pitch token: " + token);
                  lineProblems.add("Invalid pitch token: " + token);
                }
                octave++;
                kind = "^";
                break;
              case "/":
                if (kind === "^") {
                  // throw new Error("Invalid pitch token: " + token);
                  lineProblems.add("Invalid pitch token: " + token);
                }
                octave--;
                kind = "/";
                break;
              default:
                done = true;
                break;
            }
            if (done) break;
            j++;
          }
          // Index j now points to the first accidental, if any
          kind = null;
          let count = 0;
          while (j < token.length && token[j].match(/[#&%]/)) {
            if (token[j] === "#") {
              if (kind === "&" || kind === "%") {
                //throw new Error("Invalid pitch token: " + token);
                lineProblems.add("Invalid pitch token: " + token);
              }
              kind = "#";
              count++;
            } else if (token[j] === "&") {
              if (kind === "#" || kind === "%") {
                //throw new Error("Invalid pitch token: " + token);
                lineProblems.add("Invalid pitch token: " + token);
              }
              kind = "&";
              count++;
            } else if (token[j] === "%") {
              if (kind === "#" || kind === "&") {
                //throw new Error("Invalid pitch token: " + token);
                lineProblems.add("Invalid pitch token: " + token);
              }
              kind = "%";
              count++;
            }
            j++
          }
          if (count > 2) {
            //throw new Error("Invalid pitch token: " + token);
            lineProblems.add("Invalid pitch token: " + token);
          }
          // Use kind and count to assign an accidental class, the create a new pitch object
          // and add it to the pitches array and designate it as the new previous pitch.
          let accClass = null;
          switch (kind) {
            case "#":
              if (count === 1) {
                accClass = "‚ôØ"; // sharp
              } else {
                accClass = "ùÑ™"; // double sharp
              }
              break;
            case "&":
              if (count === 1) {
                accClass = "‚ô≠"; // flat
              } else {
                accClass = "ùÑ´"; // double flat
              }
              break;
            case "%":
              accClass = "‚ôÆ"; // natural
              break;
            default:
              accClass = "?"; // to be determined
          }
          // TODO deal properly with key signatures and persistence of
          // accidentals for remainder of the bar.
          accClass = this.alterations.get(letter, octave, accClass);
          let pitch = new Pitch(letter, octave, accClass);
          if (this.inChord > -1) {
            pitch.addClass('chord-pitch');
          }
          this.pitches.push(pitch);
          // console.log(letter, octave, accClass)
          prevPitch.letter = letter;
          prevPitch.octave = octave;
        }
      }
      // render = (function (svg, x0, y0, attacks, fontwidth, fontheight, bars) {
      render = (function (svg, x0, y0, bookParms, lyricLine) {
        // x0 is the x coordinate of the left edge of the line
        // y0 corresponds to the baseline of the center octave (0)
        const fontheight = bookParms.lyricFontHeight;
        const fontwidth = bookParms.lyricFontWidth;
        const attacks = lyricLine.attacks;
        const rests = lyricLine.rests;
        const bars = lyricLine.bars;
        // Draw the lines of the staff
        const yline0 = y0 + 2 * fontheight;
        const yline1 = yline0 - fontheight
        const yline2 = yline1 - fontheight
        const yline3 = yline2 - fontheight
        const xend = fontwidth * (1 + bars[bars.length - 1]); // extend line to last barline
        for (let y of [yline0, yline1, yline2, yline3]) {
          let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          line.setAttribute("x1", x0);
          line.setAttribute("y1", y);
          line.setAttribute("x2", xend);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", "lightgray");
          line.setAttribute("stroke-width", 0.5);
          svg.appendChild(line);
        };
        // Now draw barlines
        for (let n of bars) {
          if (n === 0) continue;
          let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
          let x = x0 + (n + 0.5) * fontwidth;
          line.setAttribute("x1", x);
          line.setAttribute("y1", yline3);
          line.setAttribute("x2", x);
          line.setAttribute("y2", yline0);
          line.setAttribute("stroke", "lightgray");
          line.setAttribute("stroke-width", 0.5);
          svg.appendChild(line);
        }

        // Loop through the pitches and render them at the corresponding 
        // attack locations. It is not an error if the number of pitches
        // is not equal to the number of attack locations because we may
        // be updating the rendered pitches while the user is editing.
        let i = 0;
        for (let pitch of this.pitches) {
          let x = x0;
          let y = y0;
          if (i < attacks.length) {
            x = x0 + attacks[i] * fontwidth;
            pitch.render(svg, x, y, fontheight);
          }
          i++;
        }
        // Now render the rests
        for (let rest of rests) {
          let x = x0;
          let y = yline1; // rests are rendered in the middle of the staff
          x = x0 + rest * fontwidth;
          appendSVGTextChild(svg, x, y, ";", ["rest", "grey"]);
        };
      });
    }

    // The Cue class is used render cue text in the style specified in the style sheet.
    class Cue {
      constructor(text) {
        this.text = text;
      }
      render = (function (svg, x0, y0) {
        // x0 is the x coordinate of the left edge of the line
        // y0 is the y coordinate of the base line of the cue
        appendSVGTextChild(svg, x0, y0, this.text, ["cue"]);
      });
    } // end Cue class

    class LineAnnotations {
      constructor(lyricLine, y0, cssClasses) {
        this.lyricLine = lyricLine;
        this.y0 = y0;
        this.cssClasses = cssClasses;
        this.bars = lyricLine.bars;
        this.beats = lyricLine.beats;
        this.attacks = lyricLine.attacks;
        // merge the bars and attacks array into one array by concatenating
        // the two arrays and sorting the result.
        this.positions = this.bars.concat(this.attacks).sort((a, b) => a - b);
      }

      nextBar(pos) {
        // return the position of the next barline after the current position
        // Add a lineProblem and return the pos unchanged if were at the last bar already.
        for (let i = 0; i < this.bars.length; i++) {
          let p = this.bars[i];
          if (p > pos) {
            console.log(`next bar at ${p}`)
            return p
          }
        }
        lineProblems.add("Already at last bar position")
        return pos;
      }

      nextBeat(pos) {
        for (let i = 0; i < this.beats.length; i++) {
          let p = this.beats[i];
          if (p > pos) {
            console.log(`next beat at ${p}`)
            return p
          }
        }
        lineProblems.add("Already at or past last beat position");
        return pos;
      }
      nextNote(pos) {
        for (let i = 0; i < this.attacks.length; i++) {
          let p = this.attacks[i];
          if (p > pos) {
            console.log(`next note at ${p}`)
            return p
          }
        }
        lineProblems.add("Already at or past last note position");
        return pos;
      }
      render(svg, x0, text, step) {
        if (!['bar', 'beat', 'note'].includes(step)) {
          throw new Error(`Invalid step: ${step} : must be one of 'bar', 'beat', or 'note'`);
        }
        const tokens = text.trim().split(/\s+/);
        let pos = 0;

        tokens.forEach(token => {
          switch (token) {
            case "|":
              pos = this.nextBar(pos);
              switch (step) {
                case 'beat':
                  pos = this.nextBeat(pos)
                  break;
                case 'note':
                  pos = this.nextNote(pos)
                  break
              }
              break;
            case "_":
              switch (step) {
                case 'bar':
                  pos = this.nextBar(pos);
                  break;
                case 'beat':
                  pos = this.nextBeat(pos)
                  break
                case 'note':
                  pos = this.nextNote(pos);
                  break;
              }
              break;
            default:
              let x = x0;
              x += pos * bookParameters.lyricFontWidth;
              // Replace underscores with spaces in the rendered text
              appendSVGTextChild(svg, x, this.y0, token.replace(/_/g, ' '), this.cssClasses);
              // Move to next step position if one is available
              switch (step) {
                case 'bar':
                  if (pos < this.bars[this.bars.length - 1]) {
                    pos = this.nextBar(pos);
                  }
                  break;
                case 'beat':
                  if (pos < this.beats[this.beats.length - 1]) {
                    pos = this.nextBeat(pos);
                  }
                  break;
                case 'note':
                  if (pos < this.attacks[this.attacks.length - 1]) {
                    pos = this.nextNote(pos);
                  }
                  break;
                default:
                  break;
              }
              break;
          }
          console.log(token, pos);
        });
      }
    }

    class PerBar {
      constructor(text) {
        this.text = text;
      }
      render(svg, x0, y0, lyricLine) {
        const annotations = new LineAnnotations(lyricLine, y0, ['perbar']);
        annotations.render(svg, x0, this.text, 'bar');
      }
    }

    class PerBeat {
      constructor(text) {
        this.text = text;
      }
      render(svg, x0, y0, lyricLine) {
        const annotations = new LineAnnotations(lyricLine, y0, ['perbeat']);
        annotations.render(svg, x0, this.text, 'beat');
      }
    }

    class PerNote {
      constructor(text) {
        this.text = text;
      }
      render(svg, x0, y0, lyricLine) {
        const annotations = new LineAnnotations(lyricLine, y0, ['pernote']);
        annotations.render(svg, x0, this.text, 'note');
      }
    }

    // The  Finger class is used to render fingerings. It is almost identical to the PerNote class.
    // except that it adds a small fudge to the x position to make the tiny font
    // align better with the pitch letters. 
    class Finger {
      constructor(text) {
        this.text = text;
      }
      render(svg, x0, y0, lyricLine) {
        const annotations = new LineAnnotations(lyricLine, y0, ['fingering']);
        // Add a fudge to x positions for appearance
        const x = x0 + 0.1 * bookParameters.lyricFontWidth
        annotations.render(svg, x0, this.text, 'note');
      }
    }

    // The Counter class is similar to the PerBeat class. It provides
    // an automated method for rendering beat numbers above the beats.
    // The constructor takes 4 arguments, 
    //    n, the first beat number (should be 1 unless we're starting with a partial measure)
    //    beats, an array of beat x positions,
    //    bars, an array of of bar x positions.
    // .  rhythm, an array of rhythm markup,  as created by LyricLine.extractRhythm()`
    class Counter {
      constructor(n, beats, bars, rhythm, useSubbeats = false) {
        this.n = n;
        this.beats = beats;
        this.bars = bars;
        this.rhythm = rhythm;
        // We need to generate a list of beat numbers that resets to 1
        // each time the beat position exceeds the next bar position.
        // The counting will begin with n unless n is <= 0, in which
        // case we will start with 1 for the first beat after the first bar.
        let count = (n > 0) ? n : 1;
        this.counts = [];
        let i = 0; // index into bars
        let j = 0; // index into beats
        for (let beat of this.beats) {
          if (i < this.bars.length) {
            if (beat > this.bars[i]) { // we've crossed the next bar
              count = 1;
              i++;
            }
          }
          j++;
          if (!useSubbeats) {
            this.counts.push(count);
          }
          count++;
        }
        if (!useSubbeats) return;
        // We need to add the subbeat numbers if we reach this point.
        // We need to add the subbeat numbers.
        // We will use the rhythm markup to determine the subbeat numbers.
        // The rhythm markup is a string of characters that indicate the
        // number of beats in each subbeat. For example, "16" means
        // that there are 16 subbeats in each beat. The rhythm markup
        // is a string of characters that indicate the number of beats
        // in each subbeat. For example, "16" means that there are 16
        // subbeats in each beat. The rhythm markup is a string of
        // characters that indicate the number of beats in each subbeat.
        // For example, "16" means that there are 16 subbeats in each
        // beat. The rhythm markup is a string of characters that
        // indicate the number of beats in each subbeat. For example,
        // "16" means that there are 16 subbeats in each beat. The
        // rhythm markup is a string of characters that indicate the
        // number of beats in each subbeat. For example, "16" means
        // Now we need to add the subbeat numbers.
        // We will use the rhythm markup to determine the subbeat numbers.
        // The rhythm markup is a string of characters that indicate the
        // number of beats in each subbeat. For example, "16" means
        // that there are 16 subbeats in each beat. The rhythm markup
        // is a string of characters that indicate the number of beats
        // in each subbeat. For example, "16" means that there are 16
        // subbeats in each beat. The rhythm markup is a string of
        // characters that indicate the number of beats in each subbeat.
        // For example, "16" means that there are 16 subbeats in each
        // beat. The rhythm markup is a string of characters that
        // indicate the number of beats in each subbeat. For example,
        // "16" means that there are 16 subbeats in each beat. The
        // rhythm markup is a string of
        // append rhythm to count ( minus the first char of the rhythm)
        const subbeats = this.rhythm[j].slice(1, this.rhythm[j].length)
        //console.log(beat, this.bars[i], count, subbeats);
        // if the first char of rhythm is a minus sign, we need to
        // use a hyphen instead of a number
        const c = this.rhythm[j][0] === '-' ? '-' : String(count);
        this.counts.push(c + subbeats);
        // bump the count and beat index
        count++
        j++;
      }

      render = (function (svg, x0, y0, fontwidth) {
        // x0 is the x coordinate of the left edge of the line y0 is the
        // y coordinate of the baseline of the line. 
        // fontwidth is the width of the lyric font
        // in pixels.  (the counter font will typically be
        // smaller than the lyric font) We will render the counts by
        // looping through the beats and rendering the count number
        // above each beat. 
        let i = 0;
        for (let count of this.counts) {
          let x = x0 + this.beats[i] * fontwidth;
          appendSVGTextChild(svg, x, y0, count + '', ["counter"]);
          i++;
        }
      });
    }

    // The Chord class is used to render chords symbols above beats.
    class Chord {
      constructor(text) {
        this.text = text;
        // Trim the text and split on whitespace
        this.tokens = this.text.trim().split(/\s+/);
        // Replace common abreviations with symbols, e.g. "maj" with "‚ñ≥"
        // so that, for example, "Cmaj7" will render as "C‚ñ≥7"
        this.tokens = this.tokens.map(token => {
          return token.replace(/m7b5/, "√∏7")
            .replace(/-7b5/, "√∏7")
            .replace(/maj7/, "‚ñ≥7")
            .replace(/min/, "m")
            .replace(/m/, "m")
            .replace(/dim/, "¬∞")
            .replace(/aug/, "+")
            .replace(/7b9/, "7‚ô≠9")
            .replace(/b/, "‚ô≠")
            .replace(/#/, "‚ôØ")
            .replace(/\//, "/")
        });
      }
      render = (function (svg, x0, y0, beats, fontwidth) {
        // x0 is the x coordinate of the left edge of the line
        // y0 is the y coordinate of the baseline of the line
        // fontwidth is the width of the lyric font in pixels.
        // (the chord font will typically be larger than the lyric font)
        // As with the Pitch class, we will render the expression
        // by looping through the tokens and rendering each one
        // at the next beat from the lyric line. Before rendering,
        // we split the chord tokens into the root and the chord text,
        // e.g. "Cmaj7" will be split into ["C", "maj7"]. The chord
        // text is rendered in a smaller font than the root.
        // Note, at present I'm using a couple of fudge factors to
        // get the chord text to render correctly. This is not ideal
        // and should be replaced with a more robust solution.
        const xfudge = 1.2 * fontwidth // px
        const yfudge = 4 // px
        let i = 0;
        for (let token of this.tokens) {
          const root = token[0]
          const chtext = token.slice(1)
          let x = x0;
          let y = y0;
          if (i < beats.length) {
            x = x0 + beats[i] * fontwidth;
            // replace any underscores with spaces
            appendSVGTextChild(svg, x, y, root.replace(/_/g, " "), ["chord"]);
            if (root != "_") {
              x += xfudge;
              appendSVGTextChild(svg, x, y, chtext, ["chord-text"]);
            }
          }
          i++;
        }
      })
    }
    // splitFirst splits a string on the supplied separator and returns
    // a two-element array of strings containing the part that preceded the
    // separator and the remainder of the string, e.g.
    //   splitFirst('foo: bar: blah, blah', ': ') --> ['foo', 'bar: blah, blah']
    // If the separator is not present, splitFirst returns an empty string
    // for the first element and the entire string as the remainder, e.g.
    //   splitFirst('no colons here', ': ') --> ['', 'no colons here']
    function splitFirst(str, separator) {
      const separatorIndex = str.indexOf(separator);
      if (separatorIndex === -1) {
        return ["", str];
      }
      return [str.slice(0, separatorIndex), str.slice(separatorIndex + separator.length)];
    }

    // musicToPitchLyric takes a music line (a string) and returns a pitch line  and a
    // lyric line as an object. For example, if the music line is `K#2 c; d -e f |` the
    // lyric line will be `*; * -* * |` and the pitch line will be 
    // `K#2 c d e f |`. 
    //
    // The lyric line is constructed by identifying all key signature
    // and pitch tokens in the music and removing the key signatures and
    // replacing the pitch tokens with asterisks.
    //
    // The pitch line is constructed by removing all the hold or rest
    // characters, '-' and ';'the from music line. 
    function musicToPitchLyric(musicLine) {
      let lyricLine = musicLine;
      let pitchLine = musicLine;

      // Remove key signatures and replace pitch tokens with asterisks in the lyric line
      lyricLine = lyricLine.replace(/K[#&]?\d/g, "").replace(/\^*\/*[#&%]*[a-g]/g, "*");

      // Remove hold and rest characters from the pitch line
      pitchLine = pitchLine.replace(/[-;]/g, "");

      return {
        lyric: lyricLine.trim(),
        pitch: pitchLine.trim()
      };
    }

    // stripComments removes all lines that start with a ':' character.
    function stripComments(text) {
      return text.replace(/^\s*:.*\n/g, "\n");
    }

    // The preprocessScore function is used to parse the score input
    // text and convert it into a data object with members for the title,
    // preface, lyrics, expressions, cues, pitches, chords, perbars and
    // postscript. The data object is returned.
    // It's important to understand the distinction between line groups
    // and singleton lines. A line group is a group of lines that represent
    // a line of music.  Singletons are things like title, preface, etc.
    // that appear once within a score. Within the score text, blank lines
    // i.e. /\n\s*\n/ are delimeters between singletons and line groups.
    function preprocessScore(text) {
      text = stripComments(text);
      const blocks = text.split(/\n\s*\n/);
      //console.log(blocks);
      const data = { text: text, lines: [] };

      // We must deal with three kinds of block.
      // 
      // The first kind is text block that begins with preface: or postscript:
      // or text: and may have one or more lines. Subsequent lines are
      // treated as text lines. 

      // The second kind of block is a single line that begins with
      //   title:, or zoom: It is an error if either of these keywords
      // are followed by anything other than the remainder of the line.
      //
      // The the third kind of block is one or more lines, each of which begins
      // with one of the following keywords: 
      //   cue:, perbar:,  pernote:, perbeat:, 
      //   chord:, music:, lyric:
      data.tight = false; // don't squeeze beats together.
      // loop through the blocks in reverse order.
      for (let i = blocks.length - 1; i >= 0; i--) {
        block = blocks[i].trim();
        if (block.startsWith("youtube:")) {
          // youtube video id with optional default play rate
          // e.g. youtube:12345678 0.75
          parts = block.slice(8).trim().split(" ");
          data.youtubeId = parts[0];
          if (parts.length > 1) {
            data.playRate = parseFloat(parts[1]);
          } else {
            data.playRate = 1.0;
          }
          blocks.splice(i, 1);
          continue;
        }
        if (block.startsWith("zoom:")) {
          data.zoom = block.slice(5).trim();
          blocks.splice(i, 1);
          continue;
        }
        if (block.startsWith("preface:")) {
          data.preface = block.slice(8);
          blocks.splice(i, 1);
          continue;
        }
        if (block.startsWith("postscript:")) {
          data.postscript = block.slice(11).trim();
          blocks.splice(i, 1);
          continue;
        }
        if (block.startsWith("tight:")) {
          data.tight = true;
          blocks.splice(i, 1);
          continue;
        }
        if (block.startsWith("title:")) {
          data.title = block.slice(6).trim();
          blocks.splice(i, 1);
          continue;
        }
        if (block.startsWith("zoom:")) {
          data.zoom = block.slice(5).trim();
          blocks.splice(i, 1);
          continue;
        }
      }

      // at this point only the third kind of blocks are left
      let kvlines = blocks.map(line => {
        const obj = {}; // what we will return
        if (line.startsWith("text:")) {
          obj.text = line.slice(5).trim();
          return obj;
        }
        // If we get to here, it's a music linegroup
        const parts = line.split(/\n/);
        parts.forEach(part => {
          part.trim()
          const [key, value] = splitFirst(part, ': ');
          k = key.trim();
          // Special handling for play:
          switch (k) {
            case "play":
              const parts = value.trim().split(/\s+/);
              const [min, sec] = parts[0].split(':');
              obj[k] = parseInt(min) * 60 + parseInt(sec);
              if (parts[1]) {
                obj.playRate = parseFloat(parts[1]);
              } else {
                obj.playRate = data.playRate;
              }
              break;
            default:
              if (k !== "" && value !== undefined) {
                obj[k] = value.trim();
              }
          }

        });
        return obj;
      });
      kvlines = kvlines.filter(obj => Object.keys(obj).length > 0);
      //console.log(kvlines);

      // push the remaining lines. 
      for (let kv of kvlines) {
        data.lines.push(kv);
        continue;
      }
      return data;
    }
    // countLeadingSpaces returns the number of leading spaces in the line.
    // It's needed by renderMultiline() because SVG text elements ignore leading
    // whitespace.
    function countLeadingSpaces(line) {
      let i = 0;
      while (line[i] === ' ') {
        i++;
      }
      return i;
    }

    function renderMultiline(svg, x, y, text, fontHeight, className) {
      const lines = text.split('\n');

      lines.forEach(line => {
        // We support a single '.' as a blank line indicator
        if (line.trimEnd() === '.') {
          y += fontHeight;
          return
        }
        dx = countLeadingSpaces(line) * fontHeight * 0.5 // assume fontwidth is half of font height
        // get the fontSize of the textElement
        appendSVGTextChild(svg, x + dx, y, line.trimEnd(), [className]);
        y += fontHeight
      });

      return y;
    }
    let currentlyPlaying = false;
    function playYouTubeAt(videoId, timeSeconds, rate = 1.0) {
      if (player.getPlayerState() === YT.PlayerState.PLAYING) {
        player.pauseVideo();
        return;
      }
      if (player.getVideoData().video_id !== videoId) {
        player.loadVideoById(videoId, timeSeconds);
      } else {
        player.seekTo(timeSeconds);
      }
      try {
        player.setPlaybackRate(rate);
      } catch (e) {
        alert("Can't play this video at that rate. Check the  video to see what rates are supported.");
        console.log(e);
        return;
      }
      console.log("Playing " + videoId + " from " + timeSeconds + " seconds at " + rate + "x");
      player.playVideo()
    }
    function reconstructSectionText(line) {
      let text = '';
      // Build section text from line properties
      if (line.cue) text += `cue: ${line.cue}\n`;
      if (line.music) {
        text += `music: ${line.music}\n`;
      } else if (line.pitch) {
        text = `pitch: ${line.pitch}\n`;
      }
      if (line.lyric) text += `lyric: ${line.lyric}\n`;
      if (line.counter) text += `counter: ${line.counter}\n`;
      if (line.chord) text += `chord: ${line.chord}\n`;
      if (line.text) text += `text: ${line.text}\n`;
      if (line.play) {
        const minutes = Math.floor(line.play / 60);
        const seconds = line.play - (minutes * 60);
        text += `play: ${minutes}:${seconds < 10 ? '0' + seconds : seconds}\n`
      }
      if (line.finger) text += `finger: ${line.finger}\n`;
      if (line.perbeat) text += `perbeat: ${line.perbeat}\n`;
      if (line.pernote) text += `pernote: ${line.pernote}\n`;
      if (line.perbar) text += `perbar: ${line.perbar}\n`;
      // ... add other line properties
      return text;
    }

    function reconstructFullScoreText(title, sectionEditors) {
      let text = `title: ${title}\n\n`;
      sectionEditors.forEach(editor => {
        text += editor.textContent + '\n';
      });
      return text;
    }
    // The renderScore function is used to render the score using the
    // members of the data object created by preprocessScore.
    //  - wrapper is a div element that will hold svg's we create
    //  - data is an object containing the score
    function renderScore(wrapper, data) {
      addEditor = (svg) => {
        // Creates separate editing area for an SVG section
        const editor = document.createElement('pre');
        editor.classList.add('section-editor');
        editor.setAttribute('contenteditable', 'plaintext-only');
        editor.style.display = 'none';
        wrapper.appendChild(editor);
        // Add triple tap detection because mobile devices use double-tap for zooming.
        let tapCount = 0;
        let lastTap = 0;

        svg.addEventListener('touchend', (e) => {
          const currentTime = new Date().getTime();
          const tapLength = currentTime - lastTap;

          if (tapLength < 500) { // Detect taps within 500ms
            tapCount++;
          } else {
            tapCount = 1;
            // Create and dispatch a click event for single taps
            const clickEvent = new MouseEvent('click', {
              bubbles: true,
              cancelable: true,
              view: window
            });
            e.target.dispatchEvent(clickEvent);
          }

          lastTap = currentTime;

          if (tapCount === 3) {
            editor.style.display = editor.style.display === 'none' ? 'block' : 'none';
            tapCount = 0;
          }
        });
        // Add double-click handler to toggle editor
        /*
        svg.addEventListener('dblclick', () => {
          editor.style.display = editor.style.display === 'none' ? 'block' : 'none';
        });
        */
        return editor;
      }
      // clear any existing content of the SVG element
      wrapper.innerHTML = "";
      // create an svg element
      let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      let y = 0; // y coordinate of the top of the rendered score
      wrapper.appendChild(svg)
      addEditor(svg)

      // Render any line problems that were encountered in
      // preliminary processing
      y = lineProblems.render(svg, bookParameters.leftX, y);
      lineProblems.clear();

      // Render the title at the top of the SVG element
      y += 2 * bookParameters.titleFontHeight
      appendSVGTextChild(svg, bookParameters.leftX, bookParameters.titleFontHeight, data.title, ['title']);

      // Special handling for first SVG's section editor (title block)
      const titleEditor = wrapper.querySelector('.section-editor');
      if (titleEditor) {
        let titleText = `title: ${data.title}`;

        if (data.zoom) {
          titleText += `\n\nzoom: ${data.zoom}`;
        }

        if (data.youtubeId) {
          titleText += `\n\nyoutube: ${data.youtubeId}`;
          if (data.playRate && data.playRate !== 1.0) {
            titleText += ` ${data.playRate}`;
          }
        }

        if (data.tight) {
          titleText += `\n\ntight:`;
        }

        titleEditor.textContent = titleText;
      }

      // Render the score
      data.lines.forEach((line, index) => {
        // create an svg element
        let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        let y = 0; // y coordinate of the top of the rendered score
        wrapper.appendChild(svg)
        let sectionEditor = addEditor(svg);
        // Populate editor with this section's source
        sectionEditor.textContent = reconstructSectionText(line);

        // If it's a text block, render it.
        if (line.text) {
          y += 2 * bookParameters.lyricFontHeight + bookParameters.textFontHeight;
          y = renderMultiline(svg, bookParameters.leftX, y,
            line.text, bookParameters.textFontHeight, 'text');
          y += bookParameters.textFontHeight
          return;
        }
        // Handle the music lines. If present, a music line replaces the
        // lyric and pitch lines.
        line.showLyric = true;
        if (line.music) {
          const { lyric, pitch } = musicToPitchLyric(line.music);
          line.lyric = lyric;
          line.pitch = pitch;
          line.showLyric = false;
        }
        let lyricline = undefined
        if (line.lyric) {
          lyricline = new LyricLine(
            line.lyric, data.tight, line.showLyric);
        }
        y += bookParameters.lyricFontHeight

        // Render the cue, if any
        if (line.cue) {
          if (!line.lyric) {
            y += bookParameters.lyricFontHeight;
          } else {
            y += bookParameters.lyricFontHeight;
          }
          const cue = new Cue(line.cue);
          cue.render(svg, bookParameters.leftX, y);
        }
        // Render the chords, if any
        if (line.chord && line.lyric) {
          y += bookParameters.chordFontHeight
          const chord = new Chord(line.chord);
          chord.render(svg, bookParameters.leftX, y, lyricline.beats, bookParameters.lyricFontWidth);
          // y += bookParameters.chordFontHeight / 3;
        }
        // Render per-beat items, if any
        if (line.perbeat && line.lyric) {
          y += bookParameters.perbeatFontHeight * 1.5
          const perbeat = new PerBeat(line.perbeat)
          perbeat.render(svg, bookParameters.leftX, y, lyricline)
        }
        // Render the fingerings, if any
        if (line.finger && line.lyric) {
          y += bookParameters.fingerFontHeight * 1.5
          const finger = new Finger(line.finger)
          finger.render(svg, bookParameters.leftX, y, lyricline)
        }
        // Render the pitches, if any
        if (line.pitch && line.lyric) {
          y += 1.5 * bookParameters.lyricFontHeight;
          try {
            const pitchLine = new PitchLine(line.pitch);
            pitchLine.render(svg, bookParameters.leftX, y, bookParameters, lyricline);
            y += 2 * bookParameters.lyricFontHeight;
          } catch (e) {
            lineProblems.add("Pitch line error: " + e.message);
            //console.log(e);
          }
        }
        if (line.perbar && line.lyric) {
          y += bookParameters.perbarFontHeight;
          const perbar = new PerBar(line.perbar);
          perbar.render(svg, bookParameters.leftX, y, lyricline);

        }
        // Render the lyric
        if (line.showLyric) {
          y += 1.1 * bookParameters.lyricFontHeight;
          if (line.lyric) {
            lyricline.render(svg, bookParameters.leftX, y, bookParameters.lyricFontWidth);
          }
        }

        // Render the per note expression marks, if any.
        if (line.pernote && line.lyric) {
          y += bookParameters.pernoteFontHeight * 1.5; // 2 px extra space between exprs and lyric to clear descenders
          const expr = new PerNote(line.pernote);
          // expr.render(svg, bookParameters.leftX, y, lyricline.attacks, bookParameters.lyricFontWidth);
          expr.render(svg, bookParameters.leftX, y, lyricline);
        }
        // Render the counter, if any
        if (line.counter && line.lyric) {
          y += bookParameters.counterFontHeight * 1.5
          // line counter may be an empty string or a string that should be convertible to an integer
          let npartial = 0;
          if (line.counter.length > 0) {
            try {
              npartial = parseInt(line.counter);
            } catch (e) {
              lineProblems.add(`Invalid counter value: ${line.counter}`);
            }
          }
          let bars = lyricline.bars;
          if (bars[0] == 0) {
            bars = bars.slice(1); // ignore the pseudo barline at 0
          }
          const counter = new Counter(npartial, lyricline.beats, bars, lyricline.extractRhythm());
          counter.render(svg, bookParameters.leftX, y, bookParameters.lyricFontWidth)
          // y += bookParameters.counterFontHeight / 3;
        }
        // Render any line problems that were encountered
        y = lineProblems.render(svg, bookParameters.leftX, y);
        lineProblems.clear();

        // Add click handler for play click handlers
        if (data.youtubeId && line.play !== undefined) {
          svg.style.cursor = 'pointer';
          svg.addEventListener('click', (event) => {
            if (event.detail === 1) { // Single click
              setTimeout(() => {
                if (!event.target.clickProcessed) {
                  playYouTubeAt(data.youtubeId, line.play, line.playRate || 1.0);
                }
              }, 200); // Delay to allow for double click detection
            }
            event.target.clickProcessed = (event.detail === 2);
          });
        }
      });
      // Add input handler to each section editor
      const sectionEditors = wrapper.querySelectorAll('.section-editor');
      sectionEditors.forEach(editor => {
        editor.addEventListener('input', () => {
          const activeEditor = document.activeElement;
          // Get array of all editors. 
          const allEditors = wrapper.querySelectorAll('.section-editor');

          // Update main source and render
          const fullText = Array.from(allEditors)
            .map(ed => ed.textContent.trim())
            .filter(text => text.length > 0)
            .join('\n\n');

          const scoreDiv = wrapper.closest('div.score');
          const mainEditor = scoreDiv.querySelector('pre.source');
          mainEditor.textContent = fullText;

        });
        editor.addEventListener('dblclick', () => {
          // Save editor state
          const activeEditor = document.activeElement;
          // Get index of active editor among siblings
          const allEditors = wrapper.querySelectorAll('.section-editor');
          const activeIndex = Array.from(allEditors).indexOf(activeEditor);

          const scoreDiv = wrapper.closest('div.score');
          score = scoreMap.get(scoreDiv.id);
          score.render();

          // Find and restore state of new editor at same index
          const newEditors = wrapper.querySelectorAll('.section-editor');
          const newActiveEditor = newEditors[activeIndex];
          newActiveEditor.style.display = 'block';
          newActiveEditor.focus();
          // newActiveEditor.selectionStart = newActiveEditor.selectionEnd = cursorPosition;
        });
      });
    }

    // deleteScore(id) deletes the score div with the given id and all its
    // content from the DOM along with the Insert button that follows it.
    function deleteScore(id) {
      const score = document.getElementById(id);
      if (score === null) {
        return
      }
      score.remove();
      btnId = "insert-new-" + id;
      const insertButton = document.getElementById(btnId);
      if (insertButton !== null) {
        insertButton.remove();
      }
      scoreToc(); // update the table of contents
    }
    // scoreToc is a function that generates a table of contents for the scores in the
    // current page. It creates a ul element that contains li elements for each score.
    // Each li element contains a link to the score's div element. The link text is the
    // title of the score. The title is extracted from the first line of the score's
    // source. The ul is inserted into the div with id'score-toc'.
    function scoreToc() {
      let toc = document.getElementById('score-toc');
      // if score-toc div doesn't exist, create it as the first
      // child of body
      if (toc === null) {
        const body = document.querySelector('body');
        toc = document.createElement('div');
        toc.id = 'score-toc';
        body.insertBefore(toc, body.firstChild);
      } else {
        toc.innerHTML = ''; // Clear it
      }
      const scores = document.querySelectorAll('div.score');
      if (scores.length === 0) {
        return;
      }
      const ul = document.createElement('ul');
      for (const score of scores) {
        const text = score.querySelector('pre.source').textContent.split('\n');
        // find the title line of the score's source
        const titleline = text.find(line => line.trim().startsWith('title:'));
        const title = titleline.split(':')[1].trim();
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.setAttribute('href', `#${score.id}`);
        a.textContent = title;
        li.appendChild(a);
        ul.appendChild(li);
      }
      // insert the ul of score links into the toc div
      toc.appendChild(ul);
      insertPageBreak(toc);
      return;
    }

    function newScoreContent(intChoice) {
      const choices = {
        minimal: `title: Untitled 

music: K0 c d e f |
counter: 1

`,

        cheatsheet: fqsReference
      }
      switch (intChoice) {
        case 1:
          return choices.minimal;
        case 3:
          return choices.cheatsheet
        default:
          return choices.minimal
      }
    }
    class Score {
      constructor(text) {
        this.text = text;
        this.outer = document.createElement('div');
        this.outer.classList.add('score');
        this.id = `score-${Math.random().toString(36).substring(2, 15)}`;
        this.outer.setAttribute('id', this.id);
        scoreMap.set(this.id, this);
        // the delete button goes at the top of the score
        this.deleteBtn = document.createElement('button')
        this.deleteBtn.textContent = 'Delete this score';
        this.deleteBtn.classList.add('delete-btn');
        this.outer.appendChild(this.deleteBtn)
        // next comes a wrapper div that will contain the rendered
        // and the editable source text.
        this.wrapper = document.createElement('div');
        this.wrapper.classList.add('score-wrapper');
        this.outer.appendChild(this.wrapper)
        // the inner wrapper div is where the svg's that comprise each
        // line of the rendered score will go
        this.inner = document.createElement('div');
        this.inner.classList.add('inner-wrapper');
        this.wrapper.appendChild(this.inner);
        // the source div will contain the editable <pre> element that 
        // holds the source text
        this.sourcediv = document.createElement('div');
        this.sourcediv.classList.add('source-div');
        this.wrapper.appendChild(this.sourcediv)
        // the editable pre element.
        this.source = document.createElement('pre');
        this.source.classList.add('source');
        this.source.setAttribute('contenteditable', 'plaintext-only');
        this.source.textContent = this.text;
        this.sourcediv.appendChild(this.source);
        // const tocId = "score-toc";
        this.tocLink = document.createElement('a');
        this.tocLink.setAttribute('href', `#score-toc`);
        this.tocLink.setAttribute('class', 'link-to-toc');
        this.tocLink.textContent = 'Table of Scores';
        this.outer.appendChild(this.tocLink);

        // Add event listeners
        this.deleteBtn.addEventListener('click', () => {
          if (confirm(`Are you sure you want to delete this score?`)) {
            deleteScore(this.id);
          }
        });
        this.source.addEventListener('input', () => {
          this.render();
        });
        // double click on the score to globally toggle editing
        /*
        this.outer.addEventListener('dblclick', () => {
          toggleEdit();
        });
        */
      }

      // showSourceEditor() makes the source editor visible.
      // by changing the the display style and width of the source div
      // and the width of the inner div.
      showSourceEditor() {
        this.sourcediv.style.display = 'block';
        this.sourcediv.style.width = '50%';
        this.inner.style.width = '50%';
      }
      // hideSourceEditor() makes the source editor invisible.
      // by changing the the display style and width of the source div
      // and the width of the inner div.
      hideSourceEditor() {
        this.sourcediv.style.display = 'none';
        this.inner.style.width = '100%';
      }

      // render() renders the score into the inner div.
      render() {
        // get the source text from the source pre element
        this.text = this.source.textContent;
        const data = preprocessScore(this.text);
        renderScore(this.inner, data);
        const svgElements = this.inner.querySelectorAll('svg');
        for (const svg of svgElements) {
          // calculate rendered height and adjust the svg height and viewbox
          let height = svg.getBBox().height + 30; // empirical
          // svg.setAttribute('height', height);
          let zoom = 100;
          if (data.zoom) {
            // if data.zoom can't be parsed, use 100% and add a message to the
            // lineProblems object so that the error can be displayed in the
            // SVG.
            zoom = parseInt(data.zoom, 10);
            if (isNaN(zoom)) {
              lineProblems.add("Invalid zoom value: " + data.zoom);
              zoom = 100;
            }
            // allow user to specify a zoom factor between 50 and 500%
            zoom = Math.max(50, Math.min(500, parseInt(zoom,
              10)));

            const xpix = 720 * 100. / zoom;
            svg.setAttribute('viewBox', `0 0 ${xpix} ${height}`);
          }
        }
        scoreToc(); // update the table of contents
        isDirty = true // signal that the score has been edited
      }
    }
    function insertNewScore(button, intChoice) {
      const scoreText = newScoreContent(parseInt(intChoice));
      scoreObj = new Score(scoreText);
      let div = scoreObj.outer;
      button.parentNode.insertBefore(div, button.nextSibling);

      const newScoreButton = document.createElement('button');
      newScoreButton.setAttribute('class', 'new-score-btn');
      newScoreButton.setAttribute('id', `insert-new-${div.id}`);
      newScoreButton.textContent = 'Insert New Score';
      newScoreButton.addEventListener('click', handleNewScoreButtonClick);
      div.parentNode.insertBefore(newScoreButton, div.nextSibling);

      // div.appendChild(link);
      insertPageBreak(div)
      scoreObj.render()
      forceEditMode(editModeState);
    }
    // handleNewScoreButtonClick inserts a new score into current page immediately before the
    // button that invoked it.  The new consists of a div with class'score' that contains
    // a <details> element that contains a <pre> element of class 'source' and a Save button that
    // invokes saveAsHtmlFile().
    function handleNewScoreButtonClick(event) {
      //console.log('handleNewScoreButtonClick');
      const button = event.target;
      dialog = document.getElementById('new-score-dialog');
      // replace the dialog with a clone
      // to prevent accumulation of event listeners.
      dialog.replaceWith(dialog.cloneNode(true));
      dialog = document.getElementById('new-score-dialog');

      const cancelButton = dialog.querySelector('button[type="reset"]');
      const confirmButton = dialog.querySelector('button[type="submit"]');

      const cancelHandler = () => {
        dialog.returnValue = '';
        dialog.close();
        return false;
      };
      const confirmHandler = () => {
        dialog.returnValue = dialog.querySelector('input[name="choice"]:checked').value;
        //console.log(`New score dialog submitted with ${dialog.returnValue}`);
        return false;
      };

      cancelButton.addEventListener('click', cancelHandler);
      confirmButton.addEventListener('click', confirmHandler);

      dialog.addEventListener('close', () => {
        if (dialog.returnValue !== '') {
          //console.log(`New score dialog closed with ${dialog.returnValue}`);
          insertNewScore(button, dialog.returnValue);
        }
        return false;
      });

      dialog.showModal();
      return false;
    }

    // The export method creates a text file consisting of the source texts of each
    // score in the document, catenated and separated by a blank line between scores.
    // The source texts are located in the pre elements with class'source'.
    function exportScores() {
      // Get the source texts of each score
      const scoreDivs = document.querySelectorAll('div.score');
      const scoreTexts = [];
      scoreDivs.forEach(div => {
        scoreTexts.push(div.querySelector('pre.source').textContent);
      });
      // Create a text file
      const blob = new Blob([scoreTexts.join('\nEndOfScore\n')], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.setAttribute('href', url);
      // get this html document's name and append '-source.fqs' to it.
      const fqsName = window.location.pathname.split('/').pop().replace('.html', '-source.fqs');
      a.setAttribute('download', fqsName);
      let saveInitiated = true;
      const initialTimestamp = Date.now();
      a.click();
      setTimeout(() => {
        if (saveInitiated && Date.now() - initialTimestamp > 1000) {
          // Assume save was successful if more than 1 second has passed.
          // This approach isn't foolproof, but it may be the best we can
          // do since the result of the File Save dialog is not available.
          isDirty = false;
        }
      }, 1500);
      // Revoke the object URL to avoid memory leaks.
      URL.revokeObjectURL(url);
      return false;
    }

    function appendScores(text) {
      const scoreTexts = text.split('\nEndOfScore\n');
      scoreTexts.forEach(scoreText => {
        scoreObj = new Score(scoreText);
        let div = scoreObj.outer;
        const newScoreButtons = document.querySelectorAll(`button.new-score-btn`);
        let newScoreButton = newScoreButtons[newScoreButtons.length - 1]; // get the last new score button
        newScoreButton.parentNode.insertBefore(div, newScoreButton.nextSibling);
        // Add a new score button after the div
        newScoreButton = document.createElement('button');
        newScoreButton.setAttribute('class', 'new-score-btn');
        newScoreButton.setAttribute('id', `insert-new-${div.id}`);
        newScoreButton.textContent = 'Insert New Score';
        newScoreButton.addEventListener('click', handleNewScoreButtonClick);
        div.parentNode.insertBefore(newScoreButton, div.nextSibling);

        // div.appendChild(link);
        insertPageBreak(div)
        scoreObj.render()
      });
      // Honor the current edit mode state.
      forceEditMode(editModeState);
    }

    function importFromFile() {
      const file = document.createElement('input');
      file.setAttribute('type', 'file');
      file.setAttribute('accept', '.fqs');
      file.addEventListener('change', event => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.addEventListener('load', event => {
          const text = event.target.result;
          appendScores(text);
        });
        reader.readAsText(file);
      });
      file.click();
      return false;
    }

    function importFromURL() {
      const url = prompt('Enter the URL of the .fqs file:');
      if (url) {
        fetch(url)
          .then(response => response.text())
          .then(text => {
            try {
              appendScores(text);
            } catch {
              console.error('Error fetching .fqs file:', error);
              alert('Error(s) encountered. Scores may be incorrectly rendered or may not be rendered at all.');
            }
          })
          .catch(error => {
            console.error('Error fetching .fqs file:', error);
            alert('Failed to fetch the .fqs file. Please check the URL and try again.');
          });
      }
      return false;
    }

    // updateFontSizes() updates the font sizes of the various elements of
    // scores that will be rendered as SVG objects. The font default sizes are
    // specified in the style element with id 'fqs-style', but we support
    // overriding them via the bookParameters object. If the font sizes are not
    // specified in the bookParameters object, we use the default font sizes and
    // update corresponding vars in bookParameters.
    function updateFontSizes() {
      // Update the font sizes if user has specified them.
      // First, get a reference to the stylesheet,
      const stylesheet = document.getElementById('fqs-style').sheet;
      const rules = stylesheet.cssRules || stylesheet.rules;
      // define a closure that will update the font size of a rule
      // whose index is i if the font height, fh is specified in 
      // or if not specified, assign a numeric value
      // to the value in fh.
      update = (i, fh) => {
        if (bookParameters[fh]) {
          const v = bookParameters[fh];
          rules[i].style.fontSize = v + 'px';
        } else {
          bookParameters[fh] = +rules[i].style.fontSize.slice(0, -2);
        }
      }
      // loop over the rules to update font sizes.
      for (let i = 0; i < rules.length; i++) {
        switch (rules[i].selectorText) {
          case '.title':
            update(i, "titleFontHeight")
            break;
          case '.text':
            update(i, 'textFontHeight');
            break;
          case '.preface':
            update(i, 'prefaceFontHeight');
            break;
          case '.postscript':
            update(i, 'postscriptFontHeight');
            break;
          case '.chord':
            update(i, 'chordFontHeight');
            break;
          case '.pernote':
            update(i, 'pernoteFontHeight');
            break;
          case '.fingering':
            update(i, 'fingerFontHeight');
            break;
          case '.lyric':
            update(i, 'lyricFontHeight');
            break;
          case '.pitch':
            update(i, 'pitchFontHeight');
            break;
          case '.cue':
            update(i, 'cueFontHeight');
            break;
          case '.perbar':
            update(i, 'perbarFontHeight');
            break;
          case '.perbeat':
            update(i, 'perbeatFontHeight');
            break;
          case '.counter':
            update(i, 'counterFontHeight');
            break;
          case '.rest':
            update(i, 'restFontHeight');
            break;
          case '.perline':
            update(i, 'perlineFontHeight');
            break;
          case '.lineproblem':
            update(i, 'lineproblemFontHeight');
            break;
        }
      }
    }
    function toggleLayout() {
      const scoreWrappers = document.querySelectorAll('.score-wrapper');
      scoreWrappers.forEach(wrapper => {
        switch (bookParameters.sideBySide) {
          case true:
            if (wrapper.classList.contains('side-by-side')) {
              wrapper.classList.remove('side-by-side');
            }
            break;
          case false:
            if (!wrapper.classList.contains('side-by-side')) {
              wrapper.classList.add('side-by-side');
            }
            break;
        }
      });
      // toggle the book parameter
      bookParameters.sideBySide = !bookParameters.sideBySide;
    }
    // newScoreBtnsVisible() and sourceEditorsVisible() are
    // utilities to show/hide the new score and source editors
    function newScoreBtnsVisible(visible) {
      const newScoreBtns = document.querySelectorAll('.new-score-btn');
      newScoreBtns.forEach(btn => {
        btn.style.display = visible ? 'inline-block' : 'none';
      });
    }

    function startExportButtonUpdateTimer() {
      setInterval(updateExportButtonAppearance, 500);
    }
    function updateExportButtonAppearance() {
      const exportButton = document.getElementById('exportButton');
      if (isDirty) {
        exportButton.style.backgroundColor = 'red';
        exportButton.style.color = 'white';
      } else {
        exportButton.style.backgroundColor = '';
        exportButton.style.color = '';
      }
    }

    // insertPageBreak inserts the follow content in the html document
    // with element 'el'.
    // <div style="break-after:page"></div>
    // Credit: https://stackoverflow.com/a/58245474/426853
    function insertPageBreak(el) {
      const pageBreakDiv = document.createElement('div');
      pageBreakDiv.style.breakAfter = 'page';
      el.appendChild(pageBreakDiv);
    }

    // When the window load is complete, render the scores and add listeners to
    // the buttons that invoke the functions to insert, save and delete scores.
    window.onload = () => {
      // update the stylesheet with any font sizes specified in the bookParameters object
      // We need to make sure the font size vars in bookParameters and the style rules are in sync.
      updateFontSizes();
      // Simulate click on first new score button to let user choose template
      const firstNewScoreBtn = document.getElementById('first-new-score-btn');
      firstNewScoreBtn.click();
      isDirty = false
      startExportButtonUpdateTimer();
      // toggleEdit();
    }

  </script>
<script type="text/javascript">
// This is the reference score that documents FQS usage
fqsReference=`title: FQS Reference

zoom: 130

youtube: icx52BLixaw

text: ABOUT:
FQS is a musical notation system that makes music easier to read. This page, fqs.html,
is a complete self-contained web app with no external dependencies. You can use it to
create, edit and display multiple scores using the simple text format (.fqs) described
in this reference. 
.
(In case you're wondering, the name, FQS, comes from the initials of my three grandchildren
Fiona, Quentin and Skylar.)
.
You can also map each line of notation to a specific starting time in a YouTube recording
of the piece and specify the play rate - typically to slow the playback down for careful
listening.
.
NOTE: This reference is a score, albeit one with far more text than usual. I encourage
you to use the edit area to experiment with changes. You can even save your own version
of the reference without losing this one since it's embedded in the fqs.html file.

text: NOTATION BASICS:
Let's start with an example:  Here's the melody for Happy Birthday, set in E major.

music: K#4 bb | c b e | d - bb | c b ^f | e - bb |
counter: 3

music: K#4 ^b g e | d c ^aa | g e f | e - ; |
counter: 1

text: KEY CONCEPTS
.
   Pitch:
     - Letter names instead of note symbols
.
     - Color (and italics) indicate altered (sharp or flat) pitches. Red for
       ‚ôØ and blue for ‚ô≠. Double flats (green) and double sharps (orange) are also supported
.
     - Compressed vertical spacing preserves melodic shape (like regular notation),
       but allows 3 octaves to be displayed in a single stave.
.
     - The spacing is also 'true' in the sense that each semitone is rendered exactly
       1/12th of an octave higher than the next lower pitch.
.
   Rhythm:
     - Horizontal space separates beats.
. 
     - Pitches without space between them subdivide the beat equally.
.
     - A semicolon ( ; )  indicates a rest.
.
     - Optional beat counter annotations below the staff clarify the rhythm.

text: TIGHT MODE
.
FQS supports a slightly different display format known as "tight mode" where the 
space between beats is suppressed in the notation display. It can be useful in some 
scores where the rhythm of each measure is fairly constant. Some movements from
the Bach Cello Suites are a good example of this having the majority of the measures
notated as groups of eighth notes under a single bar line.
.
Tight mode makes such scores more closely resemble the original and may enable
you to pack more measures into a line. The tradeoff is that measures with complex
rhythms may be harder to read. To use tight mode, include the keyword "tight:" on
an isolated line anywhere in your score text. The colon (:) after the word is 
required. You can conveniently toggle tight mode on and off by deleting or adding 
the colon.

text: ENTRY AND EDITING
.
To enter notation, you must activate an editing mode. You can do this clicking the 
"Show edit controls" button at the top of the page or by double-clicking on any line in
the body of any score. The difference is that the button will open a pane at the side of
the score showing the entire text of the score, whereas clicking in the score will open
a small editor for just that line.  
.
In either case, if editing is already active, the same actions will hide the editor
and return you to display mode.
.
One important difference is that editing in the side pane will update the displayed
notation immediately, whereas you must double click in the small editors to see
the result of your changes.
.
For example, the first line of the Happy Birthday sample above
was created by entering the following two lines of text:

cue: music: K#4 bb | c b e | d - bb | c b ^f | e - bb |

cue: counter: 3

text: The 'music:' keyword tells the app to interpret what follows as a line of FQS notation.
.
   - A key signature is required. In this example, K#4, indicates E major ( 4 sharps ).
.
   - No time signature is needed ( but you can indicate one with an annotation).
.
   - The vertical bar symbol ( | ) ends a measure.
.
   - A hyphen ( - ) indicates a sustained pitch.
.
By default, each pitch is rendered in the octave that puts it closest to
the preceding pitch. A preceding caret ( ^ ) raises it to the next octave.
A preceding forward slash ( / ) lowers it one octave.
.
The 'counter' keyword is optional.  It places small beat numbers below the staff.
It takes a single number as an argument to enable support for pickup (partial) measures.

text: COMPATIBILITY: 
For technical reasons, editing scores is not possible with Firefox. 
Other browsers including Chrome, Safari, etc., work correctly.

text: NOTATED CHORDS:
.
FQS supports a simple notation for pitches sounded simultaneously. A chord is rendered on
the staff as a group of pitches rotated left by 30¬∞,  like this:

music: K0 (ceg&b) /cegb c |
counter: 1

text: In the example above, the smaller, back-slanted characters indicate that all the pitches in the 
first beat are to be sounded together as a chord for one beat whereas the the four
pitches in the second beat are to be played as four sixteenth notes (assuming a quarter note beat).
.
The example above was entered as:

cue: music: K0 (ceg&b) /cegb c |

text: PAGE CONTROLS:
.
Four buttons at the top of the page allow you to save, load, and edit your work.
.
  Export -  allows you to save a local copy of all the scores on the page as
    a .fqs file.
    IMPORTANT: Don't rely your browser's Save command to save your
    work. It will save a copy of this html file without the scores.
.
  Import File - loads a .fqs file from your disk drive.
.
  Import URL - prompts you for a URL reference to load a remote .fqs file.
.
  Show (hide) Edit Controls - toggles the visibility of the editor and the buttons 
  for inserting and deleting scores.
.
EDIT CONTROLS:
.
When the Edit Controls are shown, each score has 3 buttons:
.
   Edit this score - opens a text editing window containing the score source.
   Changes you make are updated in real time in the displayed music.
.
   Delete - removes the score (after asking for confirmation). Does not affect
   underlying files, but any unexported changes will be lost.
.
   Insert New Score - Allows a new score to be inserted immediately after the
   current score.
.
WAYS TO LOSE YOUR WORK:
   1. Closing or reloading the page (without exporting first)
   2. Using your browser's Back button. The scores will be gone when you return.

text: YOUTUBE PLAYBACK:
FQS supports synchronized playback from YouTube videos. To enable this:
.
1. Add a youtube keyword with the video ID at the start of your score, e.g:
   youtube: dQw4w9WgXcQ
. 
   The youtube keyword takes an optional second argument to specify the 
   default playback speed. Most YouTube music videos support 
   0.25, 0.5, 1.0, 1.5, or 2.0 as allowed playback speed values.
.
2. Add a play keyword to any music or pitch/lyric line group, e.g.:
   play: 1:30 0.5
.  
  The play keyword takes two arguments:
     - Start time in minutes:seconds format (required)
     - Playback speed: 0.25, 0.5, 1.0, 1.5, or 2.0 (optional, defaults to 1.0)
      If given, line playback speed overrides the default speed.
.
Click any line with a 'play' keyword to start playback from its specified time.
Click again to stop playback.
.
Tip: Set the start time a couple of seconds before the first measure in the line to
give yourself enough time to get ready to play the passage along with the recording.
.
Here's a complete example. The recording is the Sarabande from J.S. Bach's Cello Suite II
in C Major, played live by Yo Yo Ma. Click either line to start playback at that line.
.
Note: The groups of back-slanted notes are FQS's way of indicating chords.

cue: Largo (mm=48)

cue: A section (player begins at repeat)
music: K0 (cg^e^c) (/d^c)--a b | (/cg^e^&b) (fb)--g a | (/bd)-ef (cg^f)--d ef | cbca bd /gf |
counter: 1
play: 11:18

cue: 5
music: K0 (/e^c^a) (/a^g)--e #fdfa | (/da^#f^c)--a (/g^d^c)--a cbag | (/#c^ga)-&bc (/d^b)-ac &e/#f | g (/g^g) - |
counter: 1
play: 11:38

text: LYRICS:
.
FQS also supports lyrics. Here's Happy Birthday again - this time in E‚ô≠ major.

pitch: K&3 bb | c b e | d bb | c b ^f | e bb |
lyric: Hap.py | birth day to | you -; Hap.py | birth day to | you -; Hap.py |
counter: 3

pitch: K&3 ^b g e | d c ^aa | g e f | e |
lyric: birth day dear | NAME * Hap.py | birth day to | you - - |
counter: 1

text: The second line above was created from the following 3 lines of text:
.
  pitch: K&3 ^b g e | d c ^aa | g e f | e |
  lyric: birth day dear | NAME * Hap.py | birth day to | you - - |
  counter: 1
.
Writing scores with lyrics requires specifying the pitches and lyrics on separate
lines. The corresponding keywords are "pitch:" and "lyric:"
. 
PITCH:
The syntax of the "pitch:" keyword is similar to that of the "music:" keyword
except that you omit hyphens and semicolons and it's not necessary to use spaces 
between pitches within a bar.  
.
In fact, bar lines are also optional, but it's wise to
include them for clarity and also, to ensure that accidentals cancel at the 
end of each measure.
.
LYRIC:
The "lyric:" keyword contains the lyrics for the line, written in a special form
that determines the placement and duration of the pitches. FQS uses certain
punctation characters to accomplish this.
.
   A period ( . ) separates syllables that occupy the same beat. Writing Happy as 'Hap.py'
   tells FQS that the two syllables share a beat, each taking half.
.
   A hyphen, ( - ) indicates a syllable that is sustained for all or part of a beat and 
   a semicolon ( ; ) is a rest.

text: CHORDS:
.
FQS supports chord abbreviations. Chords can be placed on any beat.

music: K#2 ^^g f e d | c b a g | f - - - |
counter: 1
chord: Em7 _ _ _ A7 _ _ _ Dmaj7

text: Chords can also be aligned with lyrics alone. (Very handy for songwriting.)

lyric: Fly -me to the | moon ; let me | play -a mong the | stars - ; ; |
counter: 1
chord: Am7 _ _ _ Dm7 _ _ _ G7 _ _ _ Cmaj7

text: ANNOTATIONS:
You can add annotations at several levels of granularity. Text annotations, such as this one,
may contain multiple lines and paragraphs. The built-in annotations for FQS work well, but 
you may find it easier to save the score to a pdf and use a pdf editor to mark it up.

text: CUE - cue annotations are text in a small monospace font. They're limited to one line of text.

cue: Cues, such as this one, may stand apart from the notation.

cue: You may also attach a cue to any line of notation.
music: K0 c d e f | g a b c |

text: PER BAR - bar annotations attach to individual measures. They're useful for
indicating changes in meter, measure numbers, etc., but you can use them for
any text you want to tie to a particular measure.

music: K0 ^ggg ccc | a f c | ^ggg ccc | d b g |
perbar: 6/8 3/4 6/8 3/4

text: PER BEAT - beat annotations attach to individual beats. Useful for tempo
markings but, again, use them in whatever way is useful to you.

pitch: K&3 ^b g e | d c ^aa | g e f | e |
lyric: birth day dear | NAME * Hap.py | birth day to | you - - |
counter: 1
perbeat: mm=120 _ rall. _ ùÑê _a_tempo _ _ molto_rall.

text: PER NOTE - note annotations attach to individual notes. Use them
as you wish. I tend to use them for dynamic markings.

pitch: K&3 ^b g e | d c ^aa | g e f | e |
lyric: birth day dear | NAME * Hap.py | birth day to | you - - |
pernote: mf cresc. _ _ _ ff

text: FINGERING - finger annotations attach to individual notes above the staff.

music: K0 ^g | c d e f | g - - - |
finger: 0 4 1 -1 2 4

text: EVERYTHING - Here's the last line of Happy Birthday once again, this time
with all possible annotations.

pitch: K&3 ^b g e | d c ^aa | g e f | e |
lyric: birth day dear | NAME * Hap.py | birth day to | you - - |
counter: 1
finger: | | 0 1 3
perbeat: mm=120 _ rall. _ ùÑê _a_tempo _ _ molto_rall.
pernote: mf cresc. _ _ _ ff
perbar: 3/4_Brightly

text: RHYTHM:
.
FQS can represent common rhythms cleanly and unambiguously.

cue: durations (assuming 4/4 meter)
music: c - - - | d - d - | e e e e | ff ff ff ff |
counter: 1
perbar: whole halves quarters eighths

music: ^ggg ggg ggg ggg | aaaa a-aa aa-a a--a | b-b -b- c - |
counter: 1
perbar: triplets 16ths_and_dotted_rhythms two_beat_triplet

text: FQS SYNTAX SUMMARY
.
Lyric lines define the rhythm using the following characters.
   Attack: ( * ) or a syllable of alphabetic characters.
   Sustain: '-' continues the note from the prior attack.'
   Rest: ( ; ) semicolon
   Barline: ( | ) separates measures.
   Whitespace: separates beats.
   Period: A period ( . ) separates syllables that fall in the same beat.

text: Pitch lines contain pitches, key signatures and barlines.
.
   Key signatures: 'K0' or K#|&[1-7], 
   K0 = C major, 
   K#1 = G major
   K#2 = D major
   K&1 = F major
   K&2 = B-flat major
   etc...
.
   Pitch examples:
       c : C natural, octave nearest to prior pitch 
      #d : D-sharp
     ##e : E-double-sharp
      &f : F-flat
     &&g : G-double-flat
     /&a : A-flat one octave lower
     ^&b : B-flat one octave higher
    //#c : C-sharp, two octaves lower
.
Octave marks and accidentals PRECEDE the pitch, so '/#c', NOT '/c#'' or 'c#/''
.
With the 'pitch:' keyword,  whitespace is not  significant between pitches. 'c d e f' 
is the same as 'cdef'. This is NOT true with the 'music:' keyword.
.
Barlines are needed so altered pitches cancel at end of measure.

text: ANNOTATIONS (all optional):
    cue: A line of text you want to appear as a cue.
        cues may be attached to the notation or stand alone if followed by a blank line.
    chord: chord symbols aligned to beats
    perbar: Items aligned to barlines, e.g. time signatures
    perbeat: Items aligned to beats, e.g. tempo markings
    pernote: Items aligned to attacks, e.g. dynamic markings
    finger: Fingering numbers. Rendered in tiny font above the staff.
.
    LAYOUT CHARACTERS:
    In perbar, perbeat, pernote and finger annotations, the underscore (_) and barline (|)
    are treated specially.
.
    Underscores ( _ ) are used to skip beats, barlines, or attacks in annotations. For example:
    "perbar: a_tempo _ molto_rall." puts 'a tempo' at the first measure and 'molto rall.' at 
    the third measure.
.   
    Barlines ( | ) advance the layout to the next barline. This is particularly useful in per note
    annotations to reduce the number of underscores needed to correctly place an annotation.

music: K0 ^^g f e d | c b a g | f e d b | c - - - |
pernote: a_tempo | | molto_rall.`
</script>
</body>
</html>